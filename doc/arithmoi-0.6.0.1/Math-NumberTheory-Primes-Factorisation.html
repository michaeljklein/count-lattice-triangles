<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Math.NumberTheory.Primes.Factorisation</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Math.NumberTheory.Primes.Factorisation.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">arithmoi-0.6.0.1: Efficient basic number-theoretic functions.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2011 Daniel Fischer</td></tr><tr><th>License</th><td>MIT</td></tr><tr><th>Maintainer</th><td>Daniel Fischer &lt;daniel.is.fischer@googlemail.com&gt;</td></tr><tr><th>Stability</th><td>Provisional</td></tr><tr><th>Portability</th><td>Non-portable (GHC extensions)</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Math.NumberTheory.Primes.Factorisation</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Factorisation functions</a><ul><li><a href="#g:2">Factor sieves</a></li><li><a href="#g:3">Trial division</a></li><li><a href="#g:4">Partial factorisation</a><ul><li><a href="#g:5">Single curve worker</a></li></ul></li></ul></li><li><a href="#g:6">Totients</a></li><li><a href="#g:7">Carmichael function</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Various functions related to prime factorisation.
 Many of these functions use the prime factorisation of an <code><a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a></code>.
 If several of them are used on the same <code><a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a></code>, it would be inefficient
 to recalculate the factorisation, hence there are also functions working
 on the canonical factorisation, these require that the number be positive
 and in the case of the Carmichael function that the list of prime factors
 with their multiplicities is ascending.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:factorise">factorise</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; [(<a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a>, <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a>)]</li><li class="src short"><a href="#v:defaultStdGenFactorisation">defaultStdGenFactorisation</a> :: <a href="../random-1.1/System-Random.html#t:StdGen">StdGen</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; [(<a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a>, <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a>)]</li><li class="src short"><a href="#v:stepFactorisation">stepFactorisation</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; [(<a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a>, <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a>)]</li><li class="src short"><a href="#v:factorise-39-">factorise'</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; [(<a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a>, <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a>)]</li><li class="src short"><a href="#v:defaultStdGenFactorisation-39-">defaultStdGenFactorisation'</a> :: <a href="../random-1.1/System-Random.html#t:StdGen">StdGen</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; [(<a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a>, <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a>)]</li><li class="src short"><span class="keyword">data</span> <a href="#t:FactorSieve">FactorSieve</a></li><li class="src short"><a href="#v:factorSieve">factorSieve</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="Math-NumberTheory-Primes-Factorisation.html#t:FactorSieve">FactorSieve</a></li><li class="src short"><a href="#v:sieveFactor">sieveFactor</a> :: <a href="Math-NumberTheory-Primes-Factorisation.html#t:FactorSieve">FactorSieve</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; [(<a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a>, <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a>)]</li><li class="src short"><a href="#v:trialDivisionTo">trialDivisionTo</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; [(<a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a>, <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a>)]</li><li class="src short"><a href="#v:smallFactors">smallFactors</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; ([(<a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a>, <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a>)], <a href="../base-4.10.1.0/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a>)</li><li class="src short"><a href="#v:stdGenFactorisation">stdGenFactorisation</a> :: <a href="../base-4.10.1.0/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../random-1.1/System-Random.html#t:StdGen">StdGen</a> -&gt; <a href="../base-4.10.1.0/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; [(<a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a>, <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a>)]</li><li class="src short"><a href="#v:curveFactorisation">curveFactorisation</a> :: <a href="../base-4.10.1.0/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; (<a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; (<a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; g -&gt; (<a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a>, g)) -&gt; g -&gt; <a href="../base-4.10.1.0/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; [(<a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a>, <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a>)]</li><li class="src short"><a href="#v:montgomeryFactorisation">montgomeryFactorisation</a> :: <a href="Math-NumberTheory-Moduli-Class.html#t:KnownNat">KnownNat</a> n =&gt; <a href="../base-4.10.1.0/Data-Word.html#t:Word">Word</a> -&gt; <a href="../base-4.10.1.0/Data-Word.html#t:Word">Word</a> -&gt; <a href="Math-NumberTheory-Moduli-Class.html#t:Mod">Mod</a> n -&gt; <a href="../base-4.10.1.0/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:TotientSieve">TotientSieve</a></li><li class="src short"><a href="#v:totientSieve">totientSieve</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="Math-NumberTheory-Primes-Factorisation.html#t:TotientSieve">TotientSieve</a></li><li class="src short"><a href="#v:sieveTotient">sieveTotient</a> :: <a href="Math-NumberTheory-Primes-Factorisation.html#t:TotientSieve">TotientSieve</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:CarmichaelSieve">CarmichaelSieve</a></li><li class="src short"><a href="#v:carmichaelSieve">carmichaelSieve</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="Math-NumberTheory-Primes-Factorisation.html#t:CarmichaelSieve">CarmichaelSieve</a></li><li class="src short"><a href="#v:sieveCarmichael">sieveCarmichael</a> :: <a href="Math-NumberTheory-Primes-Factorisation.html#t:CarmichaelSieve">CarmichaelSieve</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a></li></ul></div><div id="interface"><h1 id="g:1">Factorisation functions</h1><div class="doc"><p>Factorisation of <code><a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a></code>s by the elliptic curve algorithm after Montgomery.
 The algorithm is explained at
 <a href="http://programmingpraxis.com/2010/04/23/modern-elliptic-curve-factorization-part-1/">http://programmingpraxis.com/2010/04/23/modern-elliptic-curve-factorization-part-1/</a>
 and
 <a href="http://programmingpraxis.com/2010/04/27/modern-elliptic-curve-factorization-part-2/">http://programmingpraxis.com/2010/04/27/modern-elliptic-curve-factorization-part-2/</a></p><p>The implementation is not very optimised, so it is not suitable for factorising numbers
 with several huge prime divisors. However, factors of 20-25 digits are normally found in
 acceptable time. The time taken depends, however, strongly on how lucky the curve-picking
 is. With luck, even large factors can be found in seconds; on the other hand, finding small
 factors (about 12-15 digits) can take minutes when the curve-picking is bad.</p><p>Given enough time, the algorithm should be able to factor numbers of 100-120 digits, but it
 is best suited for numbers of up to 50-60 digits.</p></div><div class="top"><p class="src"><a id="v:factorise" class="def">factorise</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; [(<a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a>, <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a>)] <a href="src/Math.NumberTheory.Primes.Factorisation.Montgomery.html#factorise" class="link">Source</a> <a href="#v:factorise" class="selflink">#</a></p><div class="doc"><p><code><code><a href="Math-NumberTheory-Primes-Factorisation.html#v:factorise">factorise</a></code> n</code> produces the prime factorisation of <code>n</code>, including
   a factor of <code>(-1)</code> if <code>n &lt; 0</code>. <code><code><a href="Math-NumberTheory-Primes-Factorisation.html#v:factorise">factorise</a></code> 0</code> is an error and the
   factorisation of <code>1</code> is empty. Uses a <code><a href="../random-1.1/System-Random.html#t:StdGen">StdGen</a></code> produced in an arbitrary
   manner from the bit-pattern of <code>n</code>.</p></div></div><div class="top"><p class="src"><a id="v:defaultStdGenFactorisation" class="def">defaultStdGenFactorisation</a> :: <a href="../random-1.1/System-Random.html#t:StdGen">StdGen</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; [(<a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a>, <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a>)] <a href="src/Math.NumberTheory.Primes.Factorisation.Montgomery.html#defaultStdGenFactorisation" class="link">Source</a> <a href="#v:defaultStdGenFactorisation" class="selflink">#</a></p><div class="doc"><p><code><code><a href="Math-NumberTheory-Primes-Factorisation.html#v:defaultStdGenFactorisation">defaultStdGenFactorisation</a></code></code> first strips off all small prime factors and then,
   if the factorisation is not complete, proceeds to curve factorisation.
   For negative numbers, a factor of <code>-1</code> is included, the factorisation of <code>1</code>
   is empty. Since <code>0</code> has no prime factorisation, a zero argument causes
   an error.</p></div></div><div class="top"><p class="src"><a id="v:stepFactorisation" class="def">stepFactorisation</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; [(<a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a>, <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a>)] <a href="src/Math.NumberTheory.Primes.Factorisation.Montgomery.html#stepFactorisation" class="link">Source</a> <a href="#v:stepFactorisation" class="selflink">#</a></p><div class="doc"><p><code><code><a href="Math-NumberTheory-Primes-Factorisation.html#v:stepFactorisation">stepFactorisation</a></code></code> is like <code><a href="Math-NumberTheory-Primes-Factorisation.html#v:factorise-39-">factorise'</a></code>, except that it doesn't use a
   pseudo random generator but steps through the curves in order.
   This strategy turns out to be surprisingly fast, on average it doesn't
   seem to be slower than the <code><a href="../random-1.1/System-Random.html#t:StdGen">StdGen</a></code> based variant.</p></div></div><div class="top"><p class="src"><a id="v:factorise-39-" class="def">factorise'</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; [(<a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a>, <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a>)] <a href="src/Math.NumberTheory.Primes.Factorisation.Montgomery.html#factorise%27" class="link">Source</a> <a href="#v:factorise-39-" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Math-NumberTheory-Primes-Factorisation.html#v:factorise">factorise</a></code>, but without input checking, hence <code>n &gt; 1</code> is required.</p></div></div><div class="top"><p class="src"><a id="v:defaultStdGenFactorisation-39-" class="def">defaultStdGenFactorisation'</a> :: <a href="../random-1.1/System-Random.html#t:StdGen">StdGen</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; [(<a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a>, <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a>)] <a href="src/Math.NumberTheory.Primes.Factorisation.Montgomery.html#defaultStdGenFactorisation%27" class="link">Source</a> <a href="#v:defaultStdGenFactorisation-39-" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Math-NumberTheory-Primes-Factorisation.html#v:defaultStdGenFactorisation">defaultStdGenFactorisation</a></code>, but without input checking, so
   <code>n</code> must be larger than <code>1</code>.</p></div></div><h3 id="g:2">Factor sieves</h3><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:FactorSieve" class="def">FactorSieve</a> <a href="src/Math.NumberTheory.Primes.Sieve.Misc.html#FactorSieve" class="link">Source</a> <a href="#t:FactorSieve" class="selflink">#</a></p><div class="doc"><p>A compact store of smallest prime factors.</p></div></div><div class="top"><p class="src"><a id="v:factorSieve" class="def">factorSieve</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="Math-NumberTheory-Primes-Factorisation.html#t:FactorSieve">FactorSieve</a> <a href="src/Math.NumberTheory.Primes.Sieve.Misc.html#factorSieve" class="link">Source</a> <a href="#v:factorSieve" class="selflink">#</a></p><div class="doc"><p><code><code><a href="Math-NumberTheory-Primes-Factorisation.html#v:factorSieve">factorSieve</a></code> n</code> creates a store of smallest prime factors of the numbers not exceeding <code>n</code>.
   If you need to factorise many smallish numbers, this can give a big speedup since it avoids
   many superfluous divisions. However, a too large sieve leads to a slowdown due to cache misses.
   The prime factors are stored as <code><a href="../base-4.10.1.0/Data-Word.html#t:Word16">Word16</a></code> for compactness, so <code>n</code> must be
   smaller than <code>2^32</code>.</p></div></div><div class="top"><p class="src"><a id="v:sieveFactor" class="def">sieveFactor</a> :: <a href="Math-NumberTheory-Primes-Factorisation.html#t:FactorSieve">FactorSieve</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; [(<a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a>, <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a>)] <a href="src/Math.NumberTheory.Primes.Sieve.Misc.html#sieveFactor" class="link">Source</a> <a href="#v:sieveFactor" class="selflink">#</a></p><div class="doc"><p><code><code><a href="Math-NumberTheory-Primes-Factorisation.html#v:sieveFactor">sieveFactor</a></code> fs n</code> finds the prime factorisation of <code>n</code> using the <code><a href="Math-NumberTheory-Primes-Factorisation.html#t:FactorSieve">FactorSieve</a></code> <code>fs</code>.
   For negative <code>n</code>, a factor of <code>-1</code> is included with multiplicity <code>1</code>.
   After stripping any present factors <code>2</code>, the remaining cofactor <code>c</code> (if larger
   than <code>1</code>) is factorised with <code>fs</code>. This is most efficient of course if <code>c</code> does not
   exceed the bound with which <code>fs</code> was constructed. If it does, trial division is performed
   until either the cofactor falls below the bound or the sieve is exhausted. In the latter
   case, the elliptic curve method is used to finish the factorisation.</p></div></div><h3 id="g:3">Trial division</h3><div class="top"><p class="src"><a id="v:trialDivisionTo" class="def">trialDivisionTo</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; [(<a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a>, <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a>)] <a href="src/Math.NumberTheory.Primes.Factorisation.TrialDivision.html#trialDivisionTo" class="link">Source</a> <a href="#v:trialDivisionTo" class="selflink">#</a></p><div class="doc"><p><code><code><a href="Math-NumberTheory-Primes-Factorisation.html#v:trialDivisionTo">trialDivisionTo</a></code> bound n</code> produces a factorisation of <code>n</code> using the
   primes <code>&lt;= bound</code>. If <code>n</code> has prime divisors <code>&gt; bound</code>, the last entry
   in the list is the product of all these. If <code>n &lt;= bound^2</code>, this is a
   full factorisation, but very slow if <code>n</code> has large prime divisors.</p></div></div><h2 id="g:4">Partial factorisation</h2><div class="top"><p class="src"><a id="v:smallFactors" class="def">smallFactors</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; ([(<a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a>, <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a>)], <a href="../base-4.10.1.0/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a>) <a href="src/Math.NumberTheory.Primes.Factorisation.Montgomery.html#smallFactors" class="link">Source</a> <a href="#v:smallFactors" class="selflink">#</a></p><div class="doc"><p><code><code><a href="Math-NumberTheory-Primes-Factorisation.html#v:smallFactors">smallFactors</a></code> bound n</code> finds all prime divisors of <code>n &gt; 1</code> up to <code>bound</code> by trial division and returns the
   list of these together with their multiplicities, and a possible remaining factor which may be composite.</p></div></div><div class="top"><p class="src"><a id="v:stdGenFactorisation" class="def">stdGenFactorisation</a> <a href="src/Math.NumberTheory.Primes.Factorisation.Montgomery.html#stdGenFactorisation" class="link">Source</a> <a href="#v:stdGenFactorisation" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../base-4.10.1.0/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a></td><td class="doc"><p>Lower bound for composite divisors</p></td></tr><tr><td class="src">-&gt; <a href="../random-1.1/System-Random.html#t:StdGen">StdGen</a></td><td class="doc"><p>Standard PRNG</p></td></tr><tr><td class="src">-&gt; <a href="../base-4.10.1.0/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a></td><td class="doc"><p>Estimated number of digits of smallest prime factor</p></td></tr><tr><td class="src">-&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a></td><td class="doc"><p>The number to factorise</p></td></tr><tr><td class="src">-&gt; [(<a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a>, <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a>)]</td><td class="doc"><p>List of prime factors and exponents</p></td></tr></table></div><div class="doc"><p>A wrapper around <code><a href="Math-NumberTheory-Primes-Factorisation.html#v:curveFactorisation">curveFactorisation</a></code> providing a few default arguments.
   The primality test is <code><a href="Math-NumberTheory-Primes-Testing.html#v:bailliePSW">bailliePSW</a></code>, the <code>prng</code> function - naturally -
   <code><a href="../random-1.1/System-Random.html#v:randomR">randomR</a></code>. This function also requires small prime factors to have been
   stripped before.</p></div></div><div class="top"><p class="src"><a id="v:curveFactorisation" class="def">curveFactorisation</a> <a href="src/Math.NumberTheory.Primes.Factorisation.Montgomery.html#curveFactorisation" class="link">Source</a> <a href="#v:curveFactorisation" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../base-4.10.1.0/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a></td><td class="doc"><p>Lower bound for composite divisors</p></td></tr><tr><td class="src">-&gt; (<a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a>)</td><td class="doc"><p>A primality test</p></td></tr><tr><td class="src">-&gt; (<a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; g -&gt; (<a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a>, g))</td><td class="doc"><p>A PRNG</p></td></tr><tr><td class="src">-&gt; g</td><td class="doc"><p>Initial PRNG state</p></td></tr><tr><td class="src">-&gt; <a href="../base-4.10.1.0/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a></td><td class="doc"><p>Estimated number of digits of the smallest prime factor</p></td></tr><tr><td class="src">-&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a></td><td class="doc"><p>The number to factorise</p></td></tr><tr><td class="src">-&gt; [(<a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a>, <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a>)]</td><td class="doc"><p>List of prime factors and exponents</p></td></tr></table></div><div class="doc"><p><code><code><a href="Math-NumberTheory-Primes-Factorisation.html#v:curveFactorisation">curveFactorisation</a></code></code> is the driver for the factorisation. Its performance (and success)
   can be influenced by passing appropriate arguments. If you know that <code>n</code> has no prime divisors
   below <code>b</code>, any divisor found less than <code>b*b</code> must be prime, thus giving <code>Just (b*b)</code> as the
   first argument allows skipping the comparatively expensive primality test for those.
   If <code>n</code> is such that all prime divisors must have a specific easy to test for structure, a
   custom primality test can improve the performance (normally, it will make very little
   difference, since <code>n</code> has not many divisors, and many curves have to be tried to find one).
   More influence has the pseudo random generator (a function <code>prng</code> with <code>6 &lt;= fst (prng k s) &lt;= k-2</code>
   and an initial state for the PRNG) used to generate the curves to try. A lucky choice here can
   make a huge difference. So, if the default takes too long, try another one; or you can improve your
   chances for a quick result by running several instances in parallel.</p><p><code><code><a href="Math-NumberTheory-Primes-Factorisation.html#v:curveFactorisation">curveFactorisation</a></code></code> requires that small prime factors have been stripped before. Also, it is
   unlikely to succeed if <code>n</code> has more than one (really) large prime factor.</p></div></div><h3 id="g:5">Single curve worker</h3><div class="top"><p class="src"><a id="v:montgomeryFactorisation" class="def">montgomeryFactorisation</a> :: <a href="Math-NumberTheory-Moduli-Class.html#t:KnownNat">KnownNat</a> n =&gt; <a href="../base-4.10.1.0/Data-Word.html#t:Word">Word</a> -&gt; <a href="../base-4.10.1.0/Data-Word.html#t:Word">Word</a> -&gt; <a href="Math-NumberTheory-Moduli-Class.html#t:Mod">Mod</a> n -&gt; <a href="../base-4.10.1.0/Data-Maybe.html#t:Maybe">Maybe</a> <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> <a href="src/Math.NumberTheory.Primes.Factorisation.Montgomery.html#montgomeryFactorisation" class="link">Source</a> <a href="#v:montgomeryFactorisation" class="selflink">#</a></p><div class="doc"><p><code><code><a href="Math-NumberTheory-Primes-Factorisation.html#v:montgomeryFactorisation">montgomeryFactorisation</a></code> n b1 b2 s</code> tries to find a factor of <code>n</code> using the
   curve and point determined by the seed <code>s</code> (<code>6 &lt;= s &lt; n-1</code>), multiplying the
   point by the least common multiple of all numbers <code>&lt;= b1</code> and all primes
   between <code>b1</code> and <code>b2</code>. The idea is that there's a good chance that the order
   of the point in the curve over one prime factor divides the multiplier, but the
   order over another factor doesn't, if <code>b1</code> and <code>b2</code> are appropriately chosen.
   If they are too small, none of the orders will probably divide the multiplier,
   if they are too large, all probably will, so they should be chosen to fit
   the expected size of the smallest factor.</p><p>It is assumed that <code>n</code> has no small prime factors.</p><p>The result is maybe a nontrivial divisor of <code>n</code>.</p></div></div><h1 id="g:6">Totients</h1><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:TotientSieve" class="def">TotientSieve</a> <a href="src/Math.NumberTheory.Primes.Sieve.Misc.html#TotientSieve" class="link">Source</a> <a href="#t:TotientSieve" class="selflink">#</a></p><div class="doc"><p>A compact store of totients.</p></div></div><div class="top"><p class="src"><a id="v:totientSieve" class="def">totientSieve</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="Math-NumberTheory-Primes-Factorisation.html#t:TotientSieve">TotientSieve</a> <a href="src/Math.NumberTheory.Primes.Sieve.Misc.html#totientSieve" class="link">Source</a> <a href="#v:totientSieve" class="selflink">#</a></p><div class="doc"><p><code><code><a href="Math-NumberTheory-Primes-Factorisation.html#v:totientSieve">totientSieve</a></code> n</code> creates a store of the totients of the numbers not exceeding <code>n</code>.
   A <code><a href="Math-NumberTheory-Primes-Factorisation.html#t:TotientSieve">TotientSieve</a></code> only stores values for numbers coprime to <code>30</code> to reduce space usage.
   The maximal admissible value for <code>n</code> is <code><code><a href="../base-4.10.1.0/Prelude.html#v:fromIntegral">fromIntegral</a></code> (<code><a href="../base-4.10.1.0/Prelude.html#v:maxBound">maxBound</a></code> :: <code><a href="../base-4.10.1.0/Data-Word.html#t:Word">Word</a></code>)</code>.</p></div></div><div class="top"><p class="src"><a id="v:sieveTotient" class="def">sieveTotient</a> :: <a href="Math-NumberTheory-Primes-Factorisation.html#t:TotientSieve">TotientSieve</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> <a href="src/Math.NumberTheory.Primes.Sieve.Misc.html#sieveTotient" class="link">Source</a> <a href="#v:sieveTotient" class="selflink">#</a></p><div class="doc"><p><code><code><a href="Math-NumberTheory-Primes-Factorisation.html#v:sieveTotient">sieveTotient</a></code> ts n</code> finds the totient <code>&#960;(n)</code>, i.e. the number of integers <code>k</code> with
   <code>1 &lt;= k &lt;= n</code> and <code><code><a href="../base-4.10.1.0/Prelude.html#v:gcd">gcd</a></code> n k == 1</code>, in other words, the order of the group of units
   in <code>&#8484;/(n)</code>, using the <code><a href="Math-NumberTheory-Primes-Factorisation.html#t:TotientSieve">TotientSieve</a></code> <code>ts</code>.
   First, factors of <code>2, 3</code> and <code>5</code> are handled individually, if the remaining
   cofactor of <code>n</code> is within the sieve range, its totient is looked up, otherwise
   the calculation falls back on factorisation, first by trial division and
   if necessary, elliptic curves.</p></div></div><h1 id="g:7">Carmichael function</h1><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:CarmichaelSieve" class="def">CarmichaelSieve</a> <a href="src/Math.NumberTheory.Primes.Sieve.Misc.html#CarmichaelSieve" class="link">Source</a> <a href="#t:CarmichaelSieve" class="selflink">#</a></p><div class="doc"><p>A compact store of values of the Carmichael function.</p></div></div><div class="top"><p class="src"><a id="v:carmichaelSieve" class="def">carmichaelSieve</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="Math-NumberTheory-Primes-Factorisation.html#t:CarmichaelSieve">CarmichaelSieve</a> <a href="src/Math.NumberTheory.Primes.Sieve.Misc.html#carmichaelSieve" class="link">Source</a> <a href="#v:carmichaelSieve" class="selflink">#</a></p><div class="doc"><p><code><code><a href="Math-NumberTheory-Primes-Factorisation.html#v:carmichaelSieve">carmichaelSieve</a></code> n</code> creates a store of values of the Carmichael function
   for numbers not exceeding <code>n</code>.
   Like a <code><a href="Math-NumberTheory-Primes-Factorisation.html#t:TotientSieve">TotientSieve</a></code>, a <code><a href="Math-NumberTheory-Primes-Factorisation.html#t:CarmichaelSieve">CarmichaelSieve</a></code> only stores values for numbers coprime to <code>30</code>
   to reduce space usage. The maximal admissible value for <code>n</code> is <code><code><a href="../base-4.10.1.0/Prelude.html#v:fromIntegral">fromIntegral</a></code> (<code><a href="../base-4.10.1.0/Prelude.html#v:maxBound">maxBound</a></code> :: <code><a href="../base-4.10.1.0/Data-Word.html#t:Word">Word</a></code>)</code>.</p></div></div><div class="top"><p class="src"><a id="v:sieveCarmichael" class="def">sieveCarmichael</a> :: <a href="Math-NumberTheory-Primes-Factorisation.html#t:CarmichaelSieve">CarmichaelSieve</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> <a href="src/Math.NumberTheory.Primes.Sieve.Misc.html#sieveCarmichael" class="link">Source</a> <a href="#v:sieveCarmichael" class="selflink">#</a></p><div class="doc"><p><code><code><a href="Math-NumberTheory-Primes-Factorisation.html#v:sieveCarmichael">sieveCarmichael</a></code> cs n</code> finds the value of <code>&#955;(n)</code> (or <code>&#968;(n)</code>), the smallest positive
   integer <code>e</code> such that for all <code>a</code> with <code>gcd a n == 1</code> the congruence <code>a^e &#8801; 1 (mod n)</code> holds,
   in other words, the (smallest) exponent of the group of units in <code>&#8484;/(n)</code>.
   The strategy is analogous to <code><a href="Math-NumberTheory-Primes-Factorisation.html#v:sieveTotient">sieveTotient</a></code>.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.18.1</p></div></body></html>