<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Math.NumberTheory.Powers.Squares</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Math.NumberTheory.Powers.Squares.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">arithmoi-0.6.0.1: Efficient basic number-theoretic functions.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2011 Daniel Fischer</td></tr><tr><th>License</th><td>MIT</td></tr><tr><th>Maintainer</th><td>Daniel Fischer &lt;daniel.is.fischer@googlemail.com&gt;</td></tr><tr><th>Stability</th><td>Provisional</td></tr><tr><th>Portability</th><td>Non-portable (GHC extensions)</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Math.NumberTheory.Powers.Squares</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Square root calculation</a></li><li><a href="#g:2">Tests for squares</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Functions dealing with squares. Efficient calculation of integer square roots
 and efficient testing for squareness.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:integerSquareRoot">integerSquareRoot</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; a</li><li class="src short"><a href="#v:integerSquareRoot-39-">integerSquareRoot'</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; a</li><li class="src short"><a href="#v:integerSquareRootRem">integerSquareRootRem</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; (a, a)</li><li class="src short"><a href="#v:integerSquareRootRem-39-">integerSquareRootRem'</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; (a, a)</li><li class="src short"><a href="#v:exactSquareRoot">exactSquareRoot</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; <a href="../base-4.10.1.0/Data-Maybe.html#t:Maybe">Maybe</a> a</li><li class="src short"><a href="#v:isSquare">isSquare</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:isSquare-39-">isSquare'</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:isPossibleSquare">isPossibleSquare</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:isPossibleSquare2">isPossibleSquare2</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a></li></ul></div><div id="interface"><h1 id="g:1">Square root calculation</h1><div class="top"><p class="src"><a id="v:integerSquareRoot" class="def">integerSquareRoot</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; a <a href="src/Math.NumberTheory.Powers.Squares.html#integerSquareRoot" class="link">Source</a> <a href="#v:integerSquareRoot" class="selflink">#</a></p><div class="doc"><p>Calculate the integer square root of a nonnegative number <code>n</code>,
   that is, the largest integer <code>r</code> with <code>r*r &lt;= n</code>.
   Throws an error on negative input.</p></div></div><div class="top"><p class="src"><a id="v:integerSquareRoot-39-" class="def">integerSquareRoot'</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; a <a href="src/Math.NumberTheory.Powers.Squares.html#integerSquareRoot%27" class="link">Source</a> <a href="#v:integerSquareRoot-39-" class="selflink">#</a></p><div class="doc"><p>Calculate the integer square root of a nonnegative number <code>n</code>,
   that is, the largest integer <code>r</code> with <code>r*r &lt;= n</code>.
   The precondition <code>n &gt;= 0</code> is not checked.</p></div></div><div class="top"><p class="src"><a id="v:integerSquareRootRem" class="def">integerSquareRootRem</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; (a, a) <a href="src/Math.NumberTheory.Powers.Squares.html#integerSquareRootRem" class="link">Source</a> <a href="#v:integerSquareRootRem" class="selflink">#</a></p><div class="doc"><p>Calculate the integer square root of a nonnegative number as well as
   the difference of that number with the square of that root, that is if
   <code>(s,r) = integerSquareRootRem n</code> then <code>s^2 &lt;= n == s^2+r &lt; (s+1)^2</code>.</p></div></div><div class="top"><p class="src"><a id="v:integerSquareRootRem-39-" class="def">integerSquareRootRem'</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; (a, a) <a href="src/Math.NumberTheory.Powers.Squares.html#integerSquareRootRem%27" class="link">Source</a> <a href="#v:integerSquareRootRem-39-" class="selflink">#</a></p><div class="doc"><p>Calculate the integer square root of a nonnegative number as well as
   the difference of that number with the square of that root, that is if
   <code>(s,r) = integerSquareRootRem' n</code> then <code>s^2 &lt;= n == s^2+r &lt; (s+1)^2</code>.
   The precondition <code>n &gt;= 0</code> is not checked.</p></div></div><div class="top"><p class="src"><a id="v:exactSquareRoot" class="def">exactSquareRoot</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; <a href="../base-4.10.1.0/Data-Maybe.html#t:Maybe">Maybe</a> a <a href="src/Math.NumberTheory.Powers.Squares.html#exactSquareRoot" class="link">Source</a> <a href="#v:exactSquareRoot" class="selflink">#</a></p><div class="doc"><p>Returns <code><a href="../base-4.10.1.0/Data-Maybe.html#v:Nothing">Nothing</a></code> if the argument is not a square,
   <code><code><a href="../base-4.10.1.0/Data-Maybe.html#v:Just">Just</a></code> r</code> if <code>r*r == n</code> and <code>r &gt;= 0</code>. Avoids the expensive calculation
   of the square root if <code>n</code> is recognized as a non-square
   before, prevents repeated calculation of the square root
   if only the roots of perfect squares are needed.
   Checks for negativity and <code><a href="Math-NumberTheory-Powers-Squares.html#v:isPossibleSquare">isPossibleSquare</a></code>.</p></div></div><h1 id="g:2">Tests for squares</h1><div class="top"><p class="src"><a id="v:isSquare" class="def">isSquare</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a> <a href="src/Math.NumberTheory.Powers.Squares.html#isSquare" class="link">Source</a> <a href="#v:isSquare" class="selflink">#</a></p><div class="doc"><p>Test whether the argument is a square.
   After a number is found to be positive, first <code><a href="Math-NumberTheory-Powers-Squares.html#v:isPossibleSquare">isPossibleSquare</a></code>
   is checked, if it is, the integer square root is calculated.</p></div></div><div class="top"><p class="src"><a id="v:isSquare-39-" class="def">isSquare'</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a> <a href="src/Math.NumberTheory.Powers.Squares.html#isSquare%27" class="link">Source</a> <a href="#v:isSquare-39-" class="selflink">#</a></p><div class="doc"><p>Test whether the input (a nonnegative number) <code>n</code> is a square.
   The same as <code><a href="Math-NumberTheory-Powers-Squares.html#v:isSquare">isSquare</a></code>, but without the negativity test.
   Faster if many known positive numbers are tested.</p><p>The precondition <code>n &gt;= 0</code> is not tested, passing negative
   arguments may cause any kind of havoc.</p></div></div><div class="top"><p class="src"><a id="v:isPossibleSquare" class="def">isPossibleSquare</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a> <a href="src/Math.NumberTheory.Powers.Squares.html#isPossibleSquare" class="link">Source</a> <a href="#v:isPossibleSquare" class="selflink">#</a></p><div class="doc"><p>Test whether a non-negative number may be a square.
   Non-negativity is not checked, passing negative arguments may
   cause any kind of havoc.</p><p>First the remainder modulo 256 is checked (that can be calculated
   easily without division and eliminates about 82% of all numbers).
   After that, the remainders modulo 9, 25, 7, 11 and 13 are tested
   to eliminate altogether about 99.436% of all numbers.</p><p>This is the test used by <code><a href="Math-NumberTheory-Powers-Squares.html#v:exactSquareRoot">exactSquareRoot</a></code>. For large numbers,
   the slower but more discriminating test <code>isPossibleSqure2</code> is
   faster.</p></div></div><div class="top"><p class="src"><a id="v:isPossibleSquare2" class="def">isPossibleSquare2</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a> <a href="src/Math.NumberTheory.Powers.Squares.html#isPossibleSquare2" class="link">Source</a> <a href="#v:isPossibleSquare2" class="selflink">#</a></p><div class="doc"><p>Test whether a non-negative number may be a square.
   Non-negativity is not checked, passing negative arguments may
   cause any kind of havoc.</p><p>First the remainder modulo 256 is checked (that can be calculated
   easily without division and eliminates about 82% of all numbers).
   After that, the remainders modulo several small primes are tested
   to eliminate altogether about 99.98954% of all numbers.</p><p>For smallish to medium sized numbers, this hardly performs better
   than <code><a href="Math-NumberTheory-Powers-Squares.html#v:isPossibleSquare">isPossibleSquare</a></code>, which uses smaller arrays, but for large
   numbers, where calculating the square root becomes more expensive,
   it is much faster (if the vast majority of tested numbers aren't squares).</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.18.1</p></div></body></html>