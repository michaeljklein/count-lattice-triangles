<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Math.NumberTheory.Primes.Testing</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Math.NumberTheory.Primes.Testing.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">arithmoi-0.6.0.1: Efficient basic number-theoretic functions.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2011 Daniel Fischer</td></tr><tr><th>License</th><td>MIT</td></tr><tr><th>Maintainer</th><td>Daniel Fischer &lt;daniel.is.fischer@googlemail.com&gt;</td></tr><tr><th>Stability</th><td>Provisional</td></tr><tr><th>Portability</th><td>Non-portable (GHC extensions)</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Math.NumberTheory.Primes.Testing</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Standard tests</a></li><li><a href="#g:2">Partial tests</a></li><li><a href="#g:3">Using a sieve</a></li><li><a href="#g:4">Trial division</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Primality tests.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:isPrime">isPrime</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:isCertifiedPrime">isCertifiedPrime</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:bailliePSW">bailliePSW</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:millerRabinV">millerRabinV</a> :: <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:isStrongFermatPP">isStrongFermatPP</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:isFermatPP">isFermatPP</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:FactorSieve">FactorSieve</a></li><li class="src short"><a href="#v:fsIsPrime">fsIsPrime</a> :: <a href="Math-NumberTheory-Primes-Testing.html#t:FactorSieve">FactorSieve</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:trialDivisionPrimeTo">trialDivisionPrimeTo</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a></li></ul></div><div id="interface"><h1 id="g:1">Standard tests</h1><div class="top"><p class="src"><a id="v:isPrime" class="def">isPrime</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a> <a href="src/Math.NumberTheory.Primes.Testing.Probabilistic.html#isPrime" class="link">Source</a> <a href="#v:isPrime" class="selflink">#</a></p><div class="doc"><p><code>isPrime n</code> tests whether <code>n</code> is a prime (negative or positive).
   It is a combination of trial division and Baillie-PSW test.</p><p>If <code>isPrime n</code> returns <code>False</code> then <code>n</code> is definitely composite.
   There is a theoretical possibility that <code>isPrime n</code> is <code>True</code>,
   but in fact <code>n</code> is not prime. However, no such numbers are known
   and none exist below <code>2^64</code>. If you have found one, please report it,
   because it is a major discovery.</p></div></div><div class="top"><p class="src"><a id="v:isCertifiedPrime" class="def">isCertifiedPrime</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a> <a href="src/Math.NumberTheory.Primes.Testing.Certified.html#isCertifiedPrime" class="link">Source</a> <a href="#v:isCertifiedPrime" class="selflink">#</a></p><div class="doc"><p><code><code><a href="Math-NumberTheory-Primes-Testing.html#v:isCertifiedPrime">isCertifiedPrime</a></code> n</code> tests primality of <code>n</code>, first trial division
   by small primes is performed, then a Baillie PSW test and finally a
   prime certificate is constructed and verified, provided no step before
   found <code>n</code> to be composite. Constructing prime certificates can take
   a <em>very</em> long time, so use this with care.</p></div></div><h1 id="g:2">Partial tests</h1><div class="top"><p class="src"><a id="v:bailliePSW" class="def">bailliePSW</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a> <a href="src/Math.NumberTheory.Primes.Testing.Probabilistic.html#bailliePSW" class="link">Source</a> <a href="#v:bailliePSW" class="selflink">#</a></p><div class="doc"><p>Primality test after Baillie, Pomerance, Selfridge and Wagstaff.
   The Baillie-PSW test consists of a strong Fermat probable primality
   test followed by a (strong) Lucas primality test. This implementation
   assumes that the number <code>n</code> to test is odd and larger than <code>3</code>.
   Even and small numbers have to be handled before. Also, before
   applying this test, trial division by small primes should be performed
   to identify many composites cheaply (although the Baillie-PSW test is
   rather fast, about the same speed as a strong Fermat test for four or
   five bases usually, it is, for large numbers, much more costly than
   trial division by small primes, the primes less than <code>1000</code>, say, so
   eliminating numbers with small prime factors beforehand is more efficient).</p><p>The Baillie-PSW test is very reliable, so far no composite numbers
   passing it are known, and it is known (Gilchrist 2010) that no
   Baillie-PSW pseudoprimes exist below <code>2^64</code>. However, a heuristic argument
   by Pomerance indicates that there are likely infinitely many Baillie-PSW
   pseudoprimes. On the other hand, according to
   <a href="http://mathworld.wolfram.com/Baillie-PSWPrimalityTest.html">http://mathworld.wolfram.com/Baillie-PSWPrimalityTest.html</a> there is
   reason to believe that there are none with less than several
   thousand digits, so that for most use cases the test can be
   considered definitive.</p></div></div><div class="top"><p class="src"><a id="v:millerRabinV" class="def">millerRabinV</a> :: <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a> <a href="src/Math.NumberTheory.Primes.Testing.Probabilistic.html#millerRabinV" class="link">Source</a> <a href="#v:millerRabinV" class="selflink">#</a></p><div class="doc"><p>Miller-Rabin probabilistic primality test. It consists of the trial
 division test and several rounds of the strong Fermat test with different
 bases. The choice of trial divisors and bases are
 implementation details and may change in future silently.</p><p>First argument stands for the number of rounds of strong Fermat test.
 If it is 0, only trial division test is performed.</p><p>If <code>millerRabinV k n</code> returns <code>False</code> then <code>n</code> is definitely composite.
 Otherwise <code>n</code> may appear composite with probability <code>1/4^k</code>.</p></div></div><div class="top"><p class="src"><a id="v:isStrongFermatPP" class="def">isStrongFermatPP</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a> <a href="src/Math.NumberTheory.Primes.Testing.Probabilistic.html#isStrongFermatPP" class="link">Source</a> <a href="#v:isStrongFermatPP" class="selflink">#</a></p><div class="doc"><p><code><code><a href="Math-NumberTheory-Primes-Testing.html#v:isStrongFermatPP">isStrongFermatPP</a></code> n b</code> tests whether non-negative <code>n</code> is
   a strong Fermat probable prime for base <code>b</code>.</p><p>Apart from primes, also some composite numbers have the tested
   property, but those are rare. Very rare are composite numbers
   having the property for many bases, so testing a large prime
   candidate with several bases can identify composite numbers
   with high probability. An odd number <code>n &gt; 3</code> is prime if and
   only if <code><code><a href="Math-NumberTheory-Primes-Testing.html#v:isStrongFermatPP">isStrongFermatPP</a></code> n b</code> holds for all <code>b</code> with
   <code>2 &lt;= b &lt;= (n-1)/2</code>, but of course checking all those bases
   would be less efficient than trial division, so one normally
   checks only a relatively small number of bases, depending on
   the desired degree of certainty. The probability that a randomly
   chosen base doesn't identify a composite number <code>n</code> is less than
   <code>1/4</code>, so five to ten tests give a reasonable level of certainty
   in general.</p><p>Please consult <a href="https://miller-rabin.appspot.com">Deterministic variants of the Miller-Rabin primality test</a>
   for the best choice of bases.</p></div></div><div class="top"><p class="src"><a id="v:isFermatPP" class="def">isFermatPP</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a> <a href="src/Math.NumberTheory.Primes.Testing.Probabilistic.html#isFermatPP" class="link">Source</a> <a href="#v:isFermatPP" class="selflink">#</a></p><div class="doc"><p><code><code><a href="Math-NumberTheory-Primes-Testing.html#v:isFermatPP">isFermatPP</a></code> n b</code> tests whether <code>n</code> is a Fermat probable prime
   for the base <code>b</code>, that is, whether <code>b^(n-1) <code><a href="../base-4.10.1.0/Prelude.html#v:mod">mod</a></code> n == 1</code>.
   This is a weaker but simpler condition. However, more is lost
   in strength than is gained in simplicity, so for primality testing,
   the strong check should be used. The remarks about
   the choice of bases to test from <code><code><a href="Math-NumberTheory-Primes-Testing.html#v:isStrongFermatPP">isStrongFermatPP</a></code></code> apply
   with the modification that if <code>a</code> and <code>b</code> are Fermat bases
   for <code>n</code>, then <code>a*b</code> <em>always</em> is a Fermat base for <code>n</code> too.
   A <em>Charmichael number</em> is a composite number <code>n</code> which is a
   Fermat probable prime for all bases <code>b</code> coprime to <code>n</code>. By the
   above, only primes <code>p &lt;= n/2</code> not dividing <code>n</code> need to be tested
   to identify Carmichael numbers (however, testing all those
   primes would be less efficient than determining Carmichaelness
   from the prime factorisation; but testing an appropriate number
   of prime bases is reasonable to find out whether it's worth the
   effort to undertake the prime factorisation).</p></div></div><h1 id="g:3">Using a sieve</h1><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:FactorSieve" class="def">FactorSieve</a> <a href="src/Math.NumberTheory.Primes.Sieve.Misc.html#FactorSieve" class="link">Source</a> <a href="#t:FactorSieve" class="selflink">#</a></p><div class="doc"><p>A compact store of smallest prime factors.</p></div></div><div class="top"><p class="src"><a id="v:fsIsPrime" class="def">fsIsPrime</a> :: <a href="Math-NumberTheory-Primes-Testing.html#t:FactorSieve">FactorSieve</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a> <a href="src/Math.NumberTheory.Primes.Testing.html#fsIsPrime" class="link">Source</a> <a href="#v:fsIsPrime" class="selflink">#</a></p><div class="doc"><p>Test primality using a <code><a href="Math-NumberTheory-Primes-Testing.html#t:FactorSieve">FactorSieve</a></code>. If <code>n</code> is out of bounds
   of the sieve, fall back to <code><a href="Math-NumberTheory-Primes-Testing.html#v:isPrime">isPrime</a></code>.</p></div></div><h1 id="g:4">Trial division</h1><div class="top"><p class="src"><a id="v:trialDivisionPrimeTo" class="def">trialDivisionPrimeTo</a> :: <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Prelude.html#t:Integer">Integer</a> -&gt; <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a> <a href="src/Math.NumberTheory.Primes.Factorisation.TrialDivision.html#trialDivisionPrimeTo" class="link">Source</a> <a href="#v:trialDivisionPrimeTo" class="selflink">#</a></p><div class="doc"><p><code><code><a href="Math-NumberTheory-Primes-Testing.html#v:trialDivisionPrimeTo">trialDivisionPrimeTo</a></code> bound n</code> tests whether <code>n</code> is coprime to all primes <code>&lt;= bound</code>.
   If <code>n &lt;= bound^2</code>, this is a full prime test, but very slow if <code>n</code> has no small prime divisors.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.18.1</p></div></body></html>